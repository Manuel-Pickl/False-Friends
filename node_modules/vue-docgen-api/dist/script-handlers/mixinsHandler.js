"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bt = __importStar(require("@babel/types"));
var path = __importStar(require("path"));
var ts_map_1 = __importDefault(require("ts-map"));
var parse_1 = require("../parse");
var adaptExportsToIEV_1 = __importDefault(require("../utils/adaptExportsToIEV"));
var makePathResolver_1 = __importDefault(require("../utils/makePathResolver"));
var resolveRequired_1 = __importDefault(require("../utils/resolveRequired"));
/**
 * @returns {object} an object containing the documentations for each mixin
 * key: mixin variable name
 * value: documentation of named mixin
 */
function mixinsHandler(documentation, componentDefinition, astPath, opt) {
    var originalDirName = path.dirname(opt.filePath);
    var pathResolver = makePathResolver_1.default(originalDirName, opt.alias);
    // filter only mixins
    var mixinVariableNames = getMixinsVariableNames(componentDefinition);
    if (!mixinVariableNames || !mixinVariableNames.length) {
        return;
    }
    // get all require / import statements
    var mixinVarToFilePath = resolveRequired_1.default(astPath, mixinVariableNames);
    adaptExportsToIEV_1.default(pathResolver, mixinVarToFilePath);
    // get each doc for each mixin using parse
    var files = new ts_map_1.default();
    for (var _i = 0, _a = Object.keys(mixinVarToFilePath); _i < _a.length; _i++) {
        var varName = _a[_i];
        var _b = mixinVarToFilePath[varName], filePath = _b.filePath, exportName = _b.exportName;
        var fullFilePath = pathResolver(filePath);
        if (!/[\\/]node_modules[\\/]/.test(fullFilePath)) {
            var vars = files.get(fullFilePath) || [];
            vars.push(exportName);
            files.set(fullFilePath, vars);
        }
    }
    files.forEach(function (vars, fullFilePath) {
        if (fullFilePath && vars) {
            try {
                var mixinVar = {
                    name: '<mixin/>',
                    path: fullFilePath
                };
                parse_1.parseFile(documentation, __assign({}, opt, { filePath: fullFilePath, nameFilter: vars, mixin: mixinVar }));
                mixinVar.name = documentation.get('displayName');
            }
            catch (e) {
                // eat the error
            }
        }
    });
    documentation.set('displayName', null);
}
exports.default = mixinsHandler;
function getMixinsVariableNames(compDef) {
    var varNames = [];
    if (bt.isObjectExpression(compDef.node)) {
        var mixinProp = compDef
            .get('properties')
            .filter(function (p) { return p.node.key.name === 'mixins'; });
        var mixinPath = mixinProp.length ? mixinProp[0] : undefined;
        if (mixinPath) {
            var mixinPropertyValue = mixinPath.node.value && bt.isArrayExpression(mixinPath.node.value)
                ? mixinPath.node.value.elements
                : [];
            mixinPropertyValue.forEach(function (e) {
                if (e && bt.isIdentifier(e)) {
                    varNames.push(e.name);
                }
            });
        }
    }
    else {
        if (bt.isClassDeclaration(compDef.node) &&
            compDef.node.superClass &&
            bt.isCallExpression(compDef.node.superClass) &&
            bt.isIdentifier(compDef.node.superClass.callee) &&
            compDef.node.superClass.callee.name === 'mixins') {
            return compDef.node.superClass.arguments.reduce(function (acc, a) {
                if (bt.isIdentifier(a))
                    acc.push(a.name);
                return acc;
            }, []);
        }
    }
    return varNames;
}
