"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bt = __importStar(require("@babel/types"));
var path = __importStar(require("path"));
var parse_1 = require("../parse");
var adaptExportsToIEV_1 = __importDefault(require("../utils/adaptExportsToIEV"));
var makePathResolver_1 = __importDefault(require("../utils/makePathResolver"));
var resolveRequired_1 = __importDefault(require("../utils/resolveRequired"));
/**
 * Returns documentation of the component referenced in the extends property of the component
 * @param {NodePath} astPath
 * @param {Array<NodePath>} componentDefinitions
 * @param {string} originalFilePath
 */
function extendsHandler(documentation, componentDefinition, astPath, opt) {
    var extendsVariableName = getExtendsVariableName(componentDefinition);
    // if there is no extends or extends is a direct require
    if (!extendsVariableName) {
        return;
    }
    // get all require / import statements
    var extendsFilePath = resolveRequired_1.default(astPath, [extendsVariableName]);
    var originalDirName = path.dirname(opt.filePath);
    var pathResolver = makePathResolver_1.default(originalDirName, opt.alias);
    adaptExportsToIEV_1.default(pathResolver, extendsFilePath);
    // only look for documentation in the current project not in node_modules
    var fullFilePath = pathResolver(extendsFilePath[extendsVariableName].filePath);
    if (!/[\\/]node_modules[\\/]/.test(fullFilePath)) {
        try {
            var extendsVar = {
                name: extendsFilePath[extendsVariableName].exportName,
                path: fullFilePath
            };
            parse_1.parseFile(documentation, __assign({}, opt, { filePath: fullFilePath, nameFilter: [extendsFilePath[extendsVariableName].exportName], extends: extendsVar }));
            extendsVar.name = documentation.get('displayName');
        }
        catch (e) {
            // eat the error
        }
    }
    // make sure that the parent name does not bleed on the new doc
    documentation.set('displayName', null);
}
exports.default = extendsHandler;
function getExtendsVariableName(compDef) {
    var extendsVariable = compDef &&
        bt.isClassDeclaration(compDef.node) &&
        compDef.node.superClass &&
        bt.isIdentifier(compDef.node.superClass)
        ? compDef.get('superClass')
        : getExtendsVariableNameFromCompDef(compDef);
    if (extendsVariable) {
        var extendsValue = bt.isProperty(extendsVariable.node)
            ? extendsVariable.node.value
            : extendsVariable.node;
        return extendsValue && bt.isIdentifier(extendsValue) ? extendsValue.name : undefined;
    }
    return undefined;
}
function getExtendsVariableNameFromCompDef(compDef) {
    if (!compDef) {
        return undefined;
    }
    var compDefProperties = compDef.get('properties');
    var pathExtends = compDefProperties.value
        ? compDefProperties.filter(function (p) { return p.node.key.name === 'extends'; })
        : [];
    return pathExtends.length ? pathExtends[0] : undefined;
}
