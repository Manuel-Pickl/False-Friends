"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var fs = __importStar(require("fs"));
var path = __importStar(require("path"));
var vue_template_compiler_1 = require("vue-template-compiler");
var parse_script_1 = __importDefault(require("./parse-script"));
var parse_template_1 = __importDefault(require("./parse-template"));
var script_handlers_1 = __importDefault(require("./script-handlers"));
var template_handlers_1 = __importDefault(require("./template-handlers"));
var cacher_1 = __importDefault(require("./utils/cacher"));
var ERROR_EMPTY_DOCUMENT = 'The passed source is empty';
/**
 * parses the source and returns the doc
 * @param {string} source code whose documentation is parsed
 * @param {string} filePath path of the current file against whom to resolve the mixins
 * @returns {object} documentation object
 */
function parseFile(documentation, opt) {
    var source = fs.readFileSync(opt.filePath, {
        encoding: 'utf-8'
    });
    return parseSource(documentation, source, opt);
}
exports.parseFile = parseFile;
/**
 * parses the source and returns the doc
 * @param {string} source code whose documentation is parsed
 * @param {string} filePath path of the current file against whom to resolve the mixins
 * @returns {object} documentation object
 */
function parseSource(documentation, source, opt) {
    // if the parsed component is the result of a mixin or an extends
    documentation.setOrigin(opt);
    var singleFileComponent = /\.vue$/i.test(path.extname(opt.filePath));
    var scriptSource;
    if (source === '') {
        throw new Error(ERROR_EMPTY_DOCUMENT);
    }
    if (singleFileComponent) {
        // use padding so that errors are displayed at the correct line
        var parts = cacher_1.default(function () { return vue_template_compiler_1.parseComponent(source, { pad: 'line' }); }, source);
        if (parts.customBlocks) {
            var docsBlocks = parts.customBlocks
                .filter(function (block) { return block.type === 'docs' && block.content && block.content.length; })
                .map(function (block) { return block.content.trim(); });
            if (docsBlocks.length) {
                documentation.setDocsBlocks(docsBlocks);
            }
        }
        // get slots and props from template
        if (parts.template) {
            var extTemplSrc = parts && parts.template && parts.template.attrs ? parts.template.attrs.src : '';
            var extTemplSource = extTemplSrc && extTemplSrc.length
                ? fs.readFileSync(path.resolve(path.dirname(opt.filePath), extTemplSrc), {
                    encoding: 'utf-8'
                })
                : '';
            if (extTemplSource.length) {
                parts.template.content = extTemplSource;
            }
            var addTemplateHandlers = opt.addTemplateHandlers || [];
            parse_template_1.default(parts.template, documentation, template_handlers_1.default.concat(addTemplateHandlers), opt.filePath);
        }
        var extSrc = parts && parts.script && parts.script.attrs ? parts.script.attrs.src : '';
        var extSource = extSrc && extSrc.length
            ? fs.readFileSync(path.resolve(path.dirname(opt.filePath), extSrc), {
                encoding: 'utf-8'
            })
            : '';
        scriptSource = extSource.length ? extSource : parts.script ? parts.script.content : undefined;
        opt.lang =
            (parts.script && parts.script.attrs && parts.script.attrs.lang === 'ts') ||
                /\.tsx?$/i.test(extSrc)
                ? 'ts'
                : 'js';
    }
    else {
        scriptSource = source;
        opt.lang = /\.tsx?$/i.test(path.extname(opt.filePath)) ? 'ts' : 'js';
    }
    if (scriptSource) {
        // if jsx option is not mentionned, parse jsx in components
        opt.jsx = opt.jsx === undefined ? true : opt.jsx;
        var addScriptHandlers = opt.addScriptHandlers || [];
        if (scriptSource) {
            parse_script_1.default(scriptSource, documentation, script_handlers_1.default.concat(addScriptHandlers), opt);
        }
    }
    if (!documentation.get('displayName')) {
        // a component should always have a display name
        documentation.set('displayName', path.basename(opt.filePath).replace(/\.\w+$/, ''));
    }
}
exports.parseSource = parseSource;
